# -*- coding: utf-8 -*-
"""Machine Learning Terapan - Submission - Proyek Kedua.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lqow6kX8wnkpLBHoQw4sAFHxfT41DjAl

# **Movie Recommendation System with Collaborative Filtering**

## Project Overview

Pertumbuhan pasar industri dari film luar negeri ke film dalam negeri semakin menjanjikan. Dilihat dari  jumlah penonton bioskop yang terus meningkat setiap tahunnya. Pada tahun 2018, jumlah penonton bioskop di Indonesia sendiri mencapai lebih dari 50 juta, dengan jumlah produk film luar dan dalam negeri mencapai hampir 200 judul  yang diputar di seluruh Indonesia [1].

Dari sekian banyak film yang diproduksi, sulit bagi calon penonton untuk memutuskan mana yang akan ditonton. Menemukan sebuah film tentu saja membutuhkan waktu, apalagi film tersebut telah menentukan bahwa itu  belum tentu diinginkan oleh calon penonton setelah menonton, sehingga mereka akan menghabiskan  lebih banyak waktu untuk itu. Menonton film di bioskop, platform penyedia layanan streaming, serta menyewa dan membeli DVD juga mahal, sayang sekali jika film yang Anda tonton tidak sesuai keinginan.

Sistem rujukan adalah program atau sistem penyaringan informasi yang merupakan solusi untuk masalah kelebihan informasi dengan  menyaring beberapa informasi penting dari  informasi yang tersedia dan bertindak berdasarkan minat, hubungan minat atau perilaku pengguna dalam suatu item. Sistem rekomendasi dirancang untuk memahami dan memprediksi preferensi pengguna berdasarkan perilaku pengguna [2]. Terdapat beberapa     metode yang dapat digunakan dalam membangun sebuah sistem rekomendasi antara lain *content based filtering*, *collaborative filtering*, dan *hybrid filtering*. *Collaborative filtering* menganalisis pengalaman dan peringkat pengguna sebelumnya dan menghubungkannya dengan pengguna lain [2].

Penulis ingin mempertimbangkan sistem rekomendasi film dengan mendeteksi kesamaan film yang ditonton berdasarkan rating yang diberikan oleh pengguna (*collaborative filtering*), kemudian dimungkinkan untuk mengurutkan berdasarkan rating film yang paling mirip dan akan menjadi rekomendasi film-film yang akan datang untuk ditonton. Jadi calon penonton tidak perlu lagi membuang waktu untuk mencari film satu per satu.

## Business Understanding

Sebagai seorang Data Scientist, tentu Anda ingin memanfaatkan data tersebut untuk meningkatkan transaksi di perusahaan. Sistem ini mencoba memecahkan masalah rekomendasi yang unik yang dihasilkan dari pengabaian data khusus untuk pengguna.

### Problem Statements

Kembangkan sebuah sistem rekomendasi movie untuk menjawab permasalahan berikut:

* Dengan data rating yang Anda miliki, bagaimana perusahaan dapat merekomendasikan movie lain yang mungkin disukai dan belum pernah ditonton oleh pengguna?

### Goals

Untuk  menjawab pertanyaan tersebut, buatlah sistem rekomendasi dengan tujuan atau goals sebagai berikut:

* Menghasilkan sejumlah rekomendasi movie yang sesuai dengan preferensi pengguna dan belum pernah ditonton sebelumnya dengan teknik *collaborative filtering*.

## Data Understanding

Dataset yang digunakan berupa 2 file csv yang merupakan data rating movie dari pengguna dan data judul movie. Anda dapat mengunduh dataset ini melalui web Kaggle [berikut](https://www.kaggle.com/datasets/dev0914sharma/dataset).

### Data Loading

Supaya isi dataset lebih mudah dipahami, kita perlu melakukan proses loading data terlebih dahulu.
"""

! pip install -q kaggle

from google.colab import files

files.upload()

! mkdir ~/.kaggle

! cp kaggle.json ~/.kaggle/

! chmod 600 ~/.kaggle/kaggle.json

! kaggle datasets download dev0914sharma/dataset

! mkdir data

! unzip dataset -d data

# Import library
import pandas as pd
import numpy as np 
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt

rating = pd.read_csv('/content/data/Dataset.csv')
movie = pd.read_csv('/content/data/Movie_Id_Titles.csv')

print('Jumlah data penilaian yang diberikan pengguna: ', len(rating))
print('Jumlah data movie: ', len(movie))

"""Data penilaian yang diberikan pengguna terdapat 100003 observasi dan data movie terdapat 1682 item."""

df = rating
df

"""Perhatikanlah, data rating memiliki 100003 baris dan 4 kolom."""

df.head()

"""Dari fungsi df.head(), kita dapat mengetahui bahwa data rating terdiri dari 5 kolom dengan lima kategori rating. Kolom-kolom tersebut antara lain:


* user_id, merupakan identitas pengguna.
* item_id, merupakan identitas movie.
* rating, merupakan data rating untuk movie.
* timestamp, merupakan data waktu saat pengguna memberikan rating pada movie.

Nah, untuk melihat distribusi rating pada data, gunakan fungsi describe()
"""

df.describe()

"""Dari output di atas, diketahui bahwa nilai maksimum rating adalah 5 dan nilai minimumnya adalah 1. Artinya, skala rating berkisar antara 1 hingga 5. 

Untuk melihat berapa pengguna yang memberikan rating, jumlah movie, dan jumlah rating, jalankan kode berikut.
"""

print('Jumlah user_id: ', len(df.user_id.unique()))
print('Jumlah item_id: ', len(df.item_id.unique()))
print('Jumlah data rating: ', len(df))

movie

"""Untuk data movie memiliki 1682 judul movie dan 2 kolom yang terdiri dari id movie dan judul movie.

## Data Preparation

Pada tahap ini, Anda perlu melakukan persiapan data untuk menyandikan (encode) fitur 'user_id' dan 'item_id' ke dalam indeks integer.
"""

# Mengubah user_id menjadi list tanpa nilai yang sama
user_ids = df['user_id'].unique().tolist()
print('list user_id: ', user_ids)
 
# Melakukan encoding user_id
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded user_id : ', user_to_user_encoded)
 
# Melakukan proses encoding angka ke ke user_id
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke user_id: ', user_encoded_to_user)

"""Selanjutnya, lakukan hal yang sama pada fitur 'item_id'."""

# Mengubah item_id menjadi list tanpa nilai yang sama
movie_ids = df['item_id'].unique().tolist()
print('list item_id: ', movie_ids)
 
# Melakukan proses encoding item_id
movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}
print('encoded item_id : ', movie_to_movie_encoded)
 
# Melakukan proses encoding angka ke item_id
movie_encoded_to_movie = {i: x for i, x in enumerate(movie_ids)}
print('encoded angka ke item_id: ', movie_encoded_to_movie)

"""Berikutnya, petakan user_idd dan item_id ke dataframe yang berkaitan."""

# Mapping user_id ke dataframe user
df['user'] = df['user_id'].map(user_to_user_encoded)
 
# Mapping item_id ke dataframe movie
df['movie'] = df['item_id'].map(movie_to_movie_encoded)

"""Terakhir, cek beberapa hal dalam data seperti jumlah user, jumlah movie, dan mengubah nilai rating menjadi float."""

# Mendapatkan jumlah user
num_users = len(user_to_user_encoded)
print(num_users)
 
# Mendapatkan jumlah movie
num_movie = len(movie_encoded_to_movie)
print(num_movie)
 
# Mengubah rating menjadi nilai float
df['rating'] = df['rating'].values.astype(np.float32)
 
# Nilai minimum rating
min_rating = min(df['rating'])
 
# Nilai maksimal rating
max_rating = max(df['rating'])
 
print('Number of User: {}, Number of Movie: {}, Min Rating: {}, Max Rating: {}'.format(
    num_users, num_movie, min_rating, max_rating
))

"""### Membagi Data untuk Training dan Validasi

Pada tahap ini kita akan melakukan pembagian data menjadi data training dan validasi. Betul! Namun sebelumnya, acak datanya terlebih dahulu agar distribusinya menjadi random.
"""

# Mengacak dataset
df = df.sample(frac=1, random_state=42)
df

"""Selanjutnya, kita bagi data train dan validasi dengan komposisi 99:1. Namun sebelumnya, kita perlu memetakan (mapping) data user dan movie menjadi satu value terlebih dahulu. Lalu, buatlah rating dalam skala 0 sampai 1 agar mudah dalam melakukan proses training."""

# Membuat variabel x untuk mencocokkan data user dan movie menjadi satu value
x = df[['user', 'movie']].values
 
# Membuat variabel y untuk membuat rating dari hasil 
y = df['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values
 
# Membagi menjadi 80% data train dan 20% data validasi
train_indices = int(0.99 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)
 
print(x, y)

"""## Modeling

Pada tahap ini, kita akan mengembangkan model machine learning dengan menerapkan teknik collaborative filtering pada data.

### Proses Training

Pada tahap ini, model menghitung skor kecocokan antara pengguna dan movie dengan teknik embedding. Pertama, kita melakukan proses embedding terhadap data user dan movie. Selanjutnya, lakukan operasi perkalian dot product antara embedding user dan movie. Selain itu, kita juga dapat menambahkan bias untuk setiap user dan movie. Skor kecocokan ditetapkan dalam skala [0,1] dengan fungsi aktivasi sigmoid.

Di sini, kita membuat class RecommenderNet dengan keras Model class. Kode class RecommenderNet ini terinspirasi dari tutorial dalam situs Keras dengan beberapa adaptasi sesuai kasus yang sedang kita selesaikan.
"""

class RecommenderNet(tf.keras.Model):
 
  # Insialisasi fungsi
  def __init__(self, num_users, num_movie, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_movie = num_movie
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embedding user
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1) # layer embedding user bias
    self.movie_embedding = layers.Embedding( # layer embeddings movie
        num_movie,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.movie_bias = layers.Embedding(num_movie, 1) # layer embedding movie bias
 
  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0]) # memanggil layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # memanggil layer embedding 2
    movie_vector = self.movie_embedding(inputs[:, 1]) # memanggil layer embedding 3
    movie_bias = self.movie_bias(inputs[:, 1]) # memanggil layer embedding 4
 
    dot_user_movie = tf.tensordot(user_vector, movie_vector, 2) 
 
    x = dot_user_movie + user_bias + movie_bias
    
    return tf.nn.sigmoid(x) # activation sigmoid

"""Selanjutnya, lakukan proses compile terhadap model."""

model = RecommenderNet(num_users, num_movie, 50) # inisialisasi model
 
# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""Model ini menggunakan Binary Crossentropy untuk menghitung loss function, Adam (Adaptive Moment Estimation) sebagai optimizer, dan root mean squared error (RMSE) sebagai metrics evaluation. 

Langkah berikutnya, mulailah proses training. 
"""

# Memulai training
 
history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 512,
    epochs = 80,
    validation_data = (x_val, y_val)
)

"""## **Evaluasi**

Metrik evaluasi yang digunakan pada prediksi ini adalah root mean squared error (RMSE).

### Visualisasi Metrik

Untuk melihat visualisasi proses training, mari kita plot metrik evaluasi dengan matplotlib.
"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""Perhatikanlah, proses training model konvergen pada epochs sekitar 80. Dari proses ini, kita memperoleh nilai error akhir sebesar sekitar 0.23 dan error pada data validasi sebesar 0.24. Nilai tersebut cukup bagus untuk sistem rekomendasi.

### Mendapatkan Rekomendasi movie
"""

movie_df = movie
df = pd.read_csv('/content/data/Dataset.csv')
 
# Mengambil sample user
user_id = df.user_id.sample(1).iloc[0]
movie_visited_by_user = df[df.user_id == user_id]
 
# Operator bitwise (~), bisa diketahui di sini https://docs.python.org/3/reference/expressions.html 
movie_not_visited = movie_df[~movie_df['item_id'].isin(movie_visited_by_user.item_id.values)]['item_id'] 
movie_not_visited = list(
    set(movie_not_visited)
    .intersection(set(movie_to_movie_encoded.keys()))
)
 
movie_not_visited = [[movie_to_movie_encoded.get(x)] for x in movie_not_visited]
user_encoder = user_to_user_encoded.get(user_id)
user_movie_array = np.hstack(
    ([[user_encoder]] * len(movie_not_visited), movie_not_visited)
)

"""Selanjutnya, untuk memperoleh rekomendasi movieran, gunakan fungsi model.predict() dari library Keras dengan menerapkan kode berikut."""

ratings = model.predict(user_movie_array).flatten()
 
top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_movie_ids = [
    movie_encoded_to_movie.get(movie_not_visited[x][0]) for x in top_ratings_indices
]
 
print('Showing recommendations for users: {}'.format(user_id))
print('===' * 9)
print('movie with high ratings from user')
print('----' * 8)
 
top_movie_user = (
    movie_visited_by_user.sort_values(
        by = 'rating',
        ascending=False
    )
    .head(5)
    .item_id.values
)
 
movie_df_rows = movie_df[movie_df['item_id'].isin(top_movie_user)]
for row in movie_df_rows.itertuples():
    print(row.title)
 
print('----' * 8)
print('Top 10 movie recommendation')
print('----' * 8)
 
recommended_movie = movie_df[movie_df['item_id'].isin(recommended_movie_ids)]
for row in recommended_movie.itertuples():
    print(row.title)

"""Sebagai contoh, hasil di atas adalah rekomendasi untuk user dengan id 286. Dari output tersebut, kita dapat membandingkan antara movie with high ratings from user dan Top 10 movie recommendation untuk user.

## **Kesimpulan**

Berdasarkan dari hasil  pengujian dan analisis dari implementasi yang telah dilakukan dapat disimpulkan bahwa sistem rekomendasi dengan teknik *collaborative filtering* sudah mencapai hasil yang baik dengan nilai error akhir sebesar sekitar 0.23 dan error pada data validasi sebesar 0.24.

## **Sumber Referensi**

[1] Tren Positif Film Indonesia, ‘Industri perfilman Indonesia semakin berkembang. Tren positip dan konsisten baik dari jumlah penonton maupun jumlah judul yang terdata sejak  tahun 2016-2018’, https://indonesia.go.id/ragam/seni/sosial/tren-positif-film-indonesia, 2019. (Diakses pada 2 Agustus 2022)

[2] Reddy, S. R. S. et al, ‘Content-Based Movie  Recommendation  System Using Genre Correlation’, in Satapathy, S. C., Bhateja,  V., and Das, S. (eds) Smart Intelligent Computing and Applications. Singapore: Springer Singapore, pp. 391–397, 2019.
"""